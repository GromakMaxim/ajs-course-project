!function(e){var t={};function s(i){if(t[i])return t[i].exports;var a=t[i]={i:i,l:!1,exports:{}};return e[i].call(a.exports,a,a.exports,s),a.l=!0,a.exports}s.m=e,s.c=t,s.d=function(e,t,i){s.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},s.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(e,t){if(1&t&&(e=s(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(s.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)s.d(i,a,function(t){return e[t]}.bind(null,a));return i},s.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return s.d(t,"a",t),t},s.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},s.p="",s(s.s=1)}([function(e,t,s){},function(e,t,s){"use strict";s.r(t);s(0);var i={swordsman:"swordsman",bowman:"bowman",magician:"magician",undead:"undead",vampire:"vampire",daemon:"daemon",generic:"generic"};class a{constructor(e,t=i.generic){if(new.target===a)throw new Error("Cant create instance of Character class. Character class is abstract!");if(e<1)throw new Error("cant created Character with level "+e);this.level=e,this.attack=0,this.defence=0,this.currentHealth=50,this.maxHealth=50,this.type=t}setCurrentHealth(e){if(!(e>=0&&e<=this.maxHealth))throw new Error("the health level being set is too low");this.currentHealth=e}setMaxHealth(e){if(!(e>=0&&e>=this.currentHealth))throw new Error("the health level being set is too low");this.maxHealth=e}lvlUp(){this.increaseLvl(),this.increaseHealth(),this.increaseAttack(),this.increaseDefence()}increaseLvl(){this.level++}increaseHealth(){this.currentHealth+=80,this.currentHealth>100?(this.maxHealth=100,this.currentHealth=100):this.maxHealth=this.currentHealth}increaseAttack(){(this.maxHealth-this.currentHealth)/this.maxHealth*100<=50&&(this.attack+=.3*this.attack)}increaseDefence(){(this.maxHealth-this.currentHealth)/this.maxHealth*100<=50&&(this.defence+=.3*this.defence)}async makeDamage(e,t,s){const a=Math.max(this.attack-e.character.defence,.1*this.attack);if(e.character.currentHealth-=a,await t.showDamage(e.position,a.toFixed(0)),console.log(`${this.type} нанёс урон персонажу ${e.character.type}: ${a}`),e.character.currentHealth<=0){switch(e.character.type){case i.magician:case i.bowman:case i.swordsman:await s.heroes.deleteMemberByPosition(e.position);break;case i.vampire:case i.daemon:case i.undead:await s.enemies.deleteMemberByPosition(e.position);break;default:throw new Error("unsupported character"+e.character)}e.position===t.selectedCharacter.position&&(t.deselectCell(t.selectedCharacter.position),s.deselectAll(),t.selectedCharacter=null)}s.allChars=s.heroes.members.concat(s.enemies.members),await s.refresh(),await s.VCChecker.checkWinningCondition()}}class r{constructor(e,t){if(!(e instanceof a))throw new Error("character must be instance of Character or its children");if("number"!=typeof t)throw new Error("position must be a number");this.character=e,this.position=t}async moveToTarget(e,t){this.position=await t.navigation.findNearestPositionToTarget(this,e,t)}findClosestShooter(e){const t=e.heroes.members.filter(e=>e.character.type===i.magician||e.character.type===i.bowman);let s=null,a=99999999999;for(const i of t){const t=e.navigation.findDistanceBetween(i.position,this.position);t<a&&(a=t,s=i)}return s}findClosestEnemy(e){let t=null,s=99999999999;for(const i of e.heroes.members){const a=e.navigation.findDistanceBetween(i.position,this.position,e);a<s&&(s=a,t=i)}return t}}function n(e,t){const s=t*t-1;return 0===e?"top-left":e===s-t+1?"bottom-left":e===t-1?"top-right":e===s?"bottom-right":e>0&&e<t?"top":e>s-t?"bottom":e%t==0?"left":(e+1)%t==0?"right":"center"}class o{constructor(){this.themes=["prairie","desert","arctic","mountain"],this.pointer=0,this.isCycle=!1}setPointer(e){e>=0&&e<this.themes.length&&(this.pointer=e)}next(){return this.isCycle?(this.pointer+1<this.themes.length?this.pointer++:this.pointer=0,!0):!(this.pointer+1>this.themes.length-1)&&(this.pointer++,!0)}previous(){return this.isCycle?(this.pointer-1>=0?this.pointer--:this.pointer=this.themes.length-1,!0):this.pointer-1>=0&&(this.pointer--,!0)}getCurrentTheme(){return this.themes[this.pointer]}getThemeByIndex(e){return e>=0&&e<this.themes.length?this.themes[this.pointer]:null}}class h{constructor(e,t,s){this.members=e,this.owner=t,null!=s&&this.setPositions(s)}setPositions(e){let t;t="player"===this.owner?function(e){let t=0;const s=[];for(;s.push(t),t++,s.push(t),t+=7,!(t>=e););return s}(e):function(e){let t=6;const s=[];for(;s.push(t),t++,s.push(t),t+=7,!(t>=e););return s}(e);const s=function(e,t){const s=new Set;for(;;){const i=e[Math.floor(Math.random()*e.length)];if(s.has(i)||s.add(i),s.size===t)break}return Array.from(s)}(t,this.members.length);this.members=function(e,t){if(e.size>t.size)throw new Error("the size of the team is not equal to the number of available positions");const s=[];for(let i=0;i<e.length;i++)s.push(new r(e[i],t[i]));return s}(this.members,s)}getPositions(){return this.members.map(e=>e.position)}findMemberByPosition(e){return this.members.find(t=>t.position===e)}deleteMemberByPosition(e){this.members.splice(this.members.findIndex(t=>t.position===e),1)}lvlUp(){for(const e of this.members)e.character.lvlUp()}randomizedLvlUp(e,t){for(const s of this.members){if(Math.floor(2*Math.random())){const i=Math.floor(Math.random()*(t-e+1))+e;for(let t=e;t<i;t++)s.character.lvlUp()}}}addMember(e){if(this.getPositions().includes(e.position))throw new Error(`position ${e.position}is busy!`);this.members.push(e)}countRemainingLives(){return this.members.reduce((e,t)=>e+t.character.currentHealth,0)}}function*l(e,t){if(0===e.length)throw new Error("types array is missing");const s=e[Math.floor(Math.random()*e.length)],i=s.name.toString().toLowerCase(),a=Math.floor(Math.random()*t+1);yield new s(a,i)}function c(e,t,s,i,a){const r=[];for(let i=0;i<s;i++){const s=l(e,t);r.push(s.next().value)}return new h(r,a,i)}class m extends a{constructor(e){super(e,"swordsman"),this.attack=40,this.defence=10,this.movementDistance=4,this.attackDistance=1}}class d extends a{constructor(e){super(e,"bowman"),this.attack=25,this.defence=25,this.movementDistance=2,this.attackDistance=2}}class u extends a{constructor(e){super(e,"vampire"),this.attack=25,this.defence=25,this.movementDistance=2,this.attackDistance=2}}class g extends a{constructor(e){super(e,"undead"),this.attack=40,this.defence=10,this.movementDistance=4,this.attackDistance=1}}class f extends a{constructor(e){super(e,"daemon"),this.attack=10,this.defence=40,this.movementDistance=1,this.attackDistance=4}}var p={auto:"auto",pointer:"pointer",crosshair:"crosshair",notallowed:"not-allowed"};var w={move:"move",attack:"attack"};class y{constructor(e){this.size=e,this.lineLength=Math.sqrt(e),this.field=[],this.createField(),this.column=0,this.row=0,this.value=this.field[this.row][this.column]}createField(){let e=0;const t=Math.sqrt(this.size)-1;for(let s=0;s<=t;s++){const s=[];for(let i=0;i<=t;i++)s.push(e),e++;this.field.push(s)}}getValue(){return this.field[this.row][this.column]}getCoordinates(e){for(let t=0;t<this.lineLength;t++)for(let s=0;s<this.lineLength;s++)if(this.field[t][s]===e)return[t,s];return null}setPointerByArrayArgs(e){return this.setPointer(e[0],e[1])}setPointer(e,t){return e>=0&&e<=this.lineLength-1&&t>=0&&t<=this.lineLength-1&&(this.row=e,this.column=t,!0)}setPointerByDefault(){this.row=0,this.column=0}goLeft(){return this.column-1>=0&&(this.column--,!0)}goRight(){return this.column+1<=this.lineLength-1&&(this.column++,!0)}goUp(){return this.row-1>=0&&(this.row--,!0)}goDown(){return this.row+1<=this.lineLength-1&&(this.row++,!0)}goUpLeft(){return this.row-1>=0&&this.column-1>=0&&(this.goUp(),this.goLeft(),!0)}goDownLeft(){return this.row+1<=this.lineLength-1&&this.column-1>=0&&(this.goDown(),this.goLeft(),!0)}goUpRight(){return this.row-1>=0&&this.column+1<=this.lineLength-1&&(this.goUp(),this.goRight(),!0)}goDownRight(){return this.row+1<=this.lineLength-1&&this.column+1<=this.lineLength-1&&(this.goDown(),this.goRight(),!0)}defineActionArea(e,t,s){return new Promise(i=>{const a=[],r=e.position;if(r>t-1||r<0)throw new Error("wrong position parameter: "+e);const n=this.getCoordinates(r);if(!this.setPointerByArrayArgs(n))throw new Error("cant define such coordinates in character "+e);let o=0;if(s===w.move){o=e.character.movementDistance;let t=1;for(;t<=o;){if(!this.goUpLeft())break;a.push(this.getValue()),t++}for(this.setPointerByArrayArgs(n),t=1;t<=o;){if(!this.goUpRight())break;a.push(this.getValue()),t++}for(this.setPointerByArrayArgs(n),t=1;t<=o;){if(!this.goDownLeft())break;a.push(this.getValue()),t++}for(this.setPointerByArrayArgs(n),t=1;t<=o;){if(!this.goDownRight())break;a.push(this.getValue()),t++}for(this.setPointerByArrayArgs(n),t=1;t<=o;){if(!this.goLeft())break;a.push(this.getValue()),t++}for(this.setPointerByArrayArgs(n),t=1;t<=o;){if(!this.goRight())break;a.push(this.getValue()),t++}for(this.setPointerByArrayArgs(n),t=1;t<=o;){if(!this.goUp())break;a.push(this.getValue()),t++}for(this.setPointerByArrayArgs(n),t=1;t<=o;){if(!this.goDown())break;a.push(this.getValue()),t++}}if(s===w.attack){o=e.character.attackDistance;let t,s,i=2*o+1,n=1;for(;n<=o&&(s=this.goUp(),s);)n++;1===n&&(i=o+1);let h=1;for(;h<=i;){t=this.getValue(),a.push(t);let e=1;for(;e<=o&&(s=this.goLeft(),s);)a.push(this.getValue()),e++;for(this.setPointerByArrayArgs(this.getCoordinates(t)),e=1;e<=o&&(s=this.goRight(),s);)a.push(this.getValue()),e++;if(this.setPointerByArrayArgs(this.getCoordinates(t)),s=this.goDown(),!s)break;h++}a.splice(a.findIndex(e=>e===r),1)}a.sort((e,t)=>e-t),i(a)})}findDistanceBetween(e,t){const s=this.getCoordinates(e),i=this.getCoordinates(t);return Math.abs(s[0]-i[0])+Math.abs(s[1]-i[1])}async findNearestPositionToTarget(e,t,s){if(1===Math.abs(e.position-t.position))return e.position;const i=await this.defineActionArea(e,this.size,"move");let a,r=99999;for(const e of i)if(e!==t.position){const i=s.enemies.getPositions(),n=s.heroes.getPositions();if(!i.includes(e)&&!n.includes(e)){const s=this.findDistanceBetween(e,t.position);s<r&&(r=s,a=e)}}return a}}class b{constructor(e){this.theme=e.theme.pointer,this.enemyTeam=e.enemies,this.heroesTeam=e.heroes,this.score=e.score}}class C{constructor(e,t){if(new.target===C)throw new Error("Cant create instance of Strategy class. Character class is abstract!");this.gamePlay=e,this.gameController=t,this.navigation=new y(this.gamePlay.boardSize**2)}async findUnitsCapableToAttack(){const e=[];for(const t of this.gameController.enemies.members){const s=await this.navigation.defineActionArea(t,this.gamePlay.boardSize**2,w.attack);0!==(await this.gameController.heroes.getPositions().filter(e=>s.includes(e))).length&&e.push(t)}return e}async findWeakestUnit(e){let t=null,s=99999999;for(const i of e){const e=await this.gameController.heroes.findMemberByPosition(i);e.character.defence<s&&(s=e.character.defence,t=e)}return null!==t?t:null}async makeMaxDamage(){const e=[],t=await this.gameController.heroes.getPositions(),s=await this.findUnitsCapableToAttack();let i,a,r=0;for(const e of s){const s=await this.navigation.defineActionArea(e,this.gamePlay.boardSize**2,w.attack),n=t.filter(e=>s.includes(e)),o=await this.findWeakestUnit(n),h=Math.max(e.character.attack-o.character.defence,.1*e.character.attack);h>=r&&(r=h,i=e,a=o)}return null!=i?(e.push(i),e.push(a),e):null}}class v extends C{async process(){console.log("Attack selected");if(0!==(await this.findUnitsCapableToAttack()).length){const e=await this.makeMaxDamage();if(null!==e){const t=e[1],s=e[0];await s.character.makeDamage(t,this.gamePlay,this.gameController),console.log("Ход игрока...")}else console.log("Компьютер ждёт подходящего момента...")}else{const e=0,t=this.gameController.enemies.members.length-1,s=Math.floor(Math.random()*(t-e+1))+e,i=await this.gameController.enemies.members[s],a=await i.findClosestEnemy(this.gameController);await i.moveToTarget(a,this.gameController),console.log(`Компьютер: переход ${i.character.type} на клетку ${i.position}`)}this.gameController.refresh()}}class P extends C{async process(){console.log("Defence selected");const e=await this.makeMaxDamage();if(null!==e){const t=e[1],s=e[0];await s.character.makeDamage(t,this.gamePlay,this.gameController),console.log("Ход игрока...")}else console.log("Компьютер ждёт подходящего момента...")}}class k{constructor(e,t){this.gamePlay=e,this.gameController=t}analyze(){console.log("Ход компьютера... ");switch(this.findShooters()){case-1:case 0:new v(this.gamePlay,this.gameController).process();break;case 1:new P(this.gamePlay,this.gameController).process()}}findShooters(){const e=this.gameController.enemies.members.filter(e=>e.character.type===i.vampire||e.character.type===i.daemon).length,t=this.gameController.heroes.members.filter(e=>e.character.type===i.bowman||e.character.type===i.magician).length;return e>t?1:t===e?0:-1}}class L{constructor(e){this.lvl=e.level,this.attack=e.attack,this.defence=e.defence,this.currentHealth=e.currentHealth,this.maxHealth=e.maxHealth,this.pictures=["🎖","⚔","🛡","❤"]}getHint(){return`${this.pictures[0]+this.lvl+this.pictures[1]+this.attack+this.pictures[2]+this.defence+this.pictures[3]+this.currentHealth}/${this.maxHealth}`}}class E{constructor(){return"object"==typeof E.instance||(E.instance=this),E.instance}setGameController(e){this.gameController=e}checkWinningCondition(){return new Promise(e=>{if(0===this.gameController.enemies.members.length){console.log("Player has won!"),this.gameController.score+=this.gameController.calculateScore();if(this.gameController.theme.next()){const e=this.gameController.theme.pointer+1;this.gameController.nextStage(e)}else this.gameController.isBlocked=!0;e(!0)}0===this.gameController.heroes.members.length&&(console.log("Computer has won!"),this.gameController.isBlocked=!0,e(!0)),e(!1)})}}class A{constructor(){return"object"==typeof A.instance||(A.instance=this),A.instance}save(e){localStorage.setItem("state",JSON.stringify(e))}load(){try{return JSON.parse(localStorage.getItem("state"))}catch(e){throw new Error("Invalid state")}}}class D extends a{constructor(e){super(e,"magician"),this.attack=10,this.defence=40,this.movementDistance=1,this.attackDistance=4}}const S=new class{constructor(){this.boardSize=8,this.container=null,this.boardEl=null,this.cells=[],this.cellClickListeners=[],this.cellEnterListeners=[],this.cellLeaveListeners=[],this.newGameListeners=[],this.saveGameListeners=[],this.loadGameListeners=[],this.selectedCharacter=null}bindToDOM(e){if(!(e instanceof HTMLElement))throw new Error("container is not HTMLElement");this.container=e}drawUi(e){this.checkBinding(),this.container.innerHTML='\n      <div class="controls">\n        <button data-id="action-restart" class="btn">New Game</button>\n        <button data-id="action-save" class="btn">Save Game</button>\n        <button data-id="action-load" class="btn">Load Game</button>\n      </div>\n      <div class="board-container">\n        <div data-id="board" class="board"></div>\n      </div>\n    ',this.newGameEl=this.container.querySelector("[data-id=action-restart]"),this.saveGameEl=this.container.querySelector("[data-id=action-save]"),this.loadGameEl=this.container.querySelector("[data-id=action-load]"),this.newGameEl.addEventListener("click",e=>this.onNewGameClick(e)),this.saveGameEl.addEventListener("click",e=>this.onSaveGameClick(e)),this.loadGameEl.addEventListener("click",e=>this.onLoadGameClick(e)),this.boardEl=this.container.querySelector("[data-id=board]"),this.boardEl.classList.add(e);for(let e=0;e<this.boardSize**2;e++){const t=document.createElement("div");t.classList.add("cell","map-tile","map-tile-"+n(e,this.boardSize)),t.addEventListener("mouseenter",e=>this.onCellEnter(e)),t.addEventListener("mouseleave",e=>this.onCellLeave(e)),t.addEventListener("click",e=>this.onCellClick(e)),this.boardEl.appendChild(t)}this.cells=Array.from(this.boardEl.children)}redrawPositions(e){for(const e of this.cells)e.innerHTML="";for(const s of e){const e=this.boardEl.children[s.position],i=document.createElement("div");i.classList.add("character",s.character.type);const a=document.createElement("div");a.classList.add("health-level");const r=document.createElement("div");r.classList.add("health-level-indicator","health-level-indicator-"+((t=s.character.currentHealth)<15?"critical":t<50?"normal":"high")),r.style.width=s.character.currentHealth+"%",a.appendChild(r),i.appendChild(a),e.appendChild(i)}var t}addCellEnterListener(e){this.cellEnterListeners.push(e)}addCellLeaveListener(e){this.cellLeaveListeners.push(e)}addCellClickListener(e){this.cellClickListeners.push(e)}addNewGameListener(e){this.newGameListeners.push(e)}addSaveGameListener(e){this.saveGameListeners.push(e)}addLoadGameListener(e){this.loadGameListeners.push(e)}onCellEnter(e){e.preventDefault();const t=this.cells.indexOf(e.currentTarget);this.cellEnterListeners.forEach(e=>e.call(null,t))}onCellLeave(e){e.preventDefault();const t=this.cells.indexOf(e.currentTarget);this.cellLeaveListeners.forEach(e=>e.call(null,t))}onCellClick(e){const t=this.cells.indexOf(e.currentTarget);this.cellClickListeners.forEach(e=>e.call(null,t))}onNewGameClick(e){e.preventDefault(),this.newGameListeners.forEach(e=>e.call(null))}onSaveGameClick(e){e.preventDefault(),this.saveGameListeners.forEach(e=>e.call(null))}onLoadGameClick(e){e.preventDefault(),this.loadGameListeners.forEach(e=>e.call(null))}static showError(e){alert(e)}static showMessage(e){alert(e)}selectCell(e,t="yellow"){this.deselectCell(e),this.cells[e].classList.add("selected","selected-"+t)}deselectCell(e){const t=this.cells[e];t.classList.remove(...Array.from(t.classList).filter(e=>e.startsWith("selected")))}showCellTooltip(e,t){this.cells[t].title=e}hideCellTooltip(e){this.cells[e].title=""}showDamage(e,t){return new Promise(s=>{const i=this.cells[e],a=document.createElement("span");a.textContent=t,a.classList.add("damage"),i.appendChild(a),a.addEventListener("animationend",()=>{i.removeChild(a),s()})})}setCursor(e){this.boardEl.style.cursor=e}checkBinding(){if(null===this.container)throw new Error("GamePlay not bind to DOM")}};S.bindToDOM(document.querySelector("#game-container"));const x=new A(localStorage);new class{constructor(e,t){this.gamePlay=e,this.stateService=t,this.navigation=new y(this.gamePlay.boardSize**2),this.theme=new o,this.strategyAnalyzer=new k(this.gamePlay,this),this.isBlocked=!1,this.stateService=new A,this.VCChecker=new E,this.survivors=[],this.score=0}init(){this.gamePlay.drawUi(this.theme.getCurrentTheme()),this.isBlocked=!1,this.heroes=c([m,d],1,2,this.gamePlay.boardSize**2,"player"),this.enemies=c([g,f,u],1,2,this.gamePlay.boardSize**2,"enemy"),this.allChars=this.heroes.members.concat(this.enemies.members),this.refresh(),this.gamePlay.addCellLeaveListener(e=>this.onCellLeave(e)),this.gamePlay.addCellEnterListener(e=>this.onCellEnter(e)),this.gamePlay.addCellClickListener(e=>this.onCellClick(e)),this.gamePlay.addNewGameListener(()=>this.newGame()),this.gamePlay.addSaveGameListener(()=>this.saveGame()),this.gamePlay.addLoadGameListener(()=>this.loadGame()),this.VCChecker.setGameController(this)}nextStage(e){console.log("Switching to stage "+e),this.heroes.lvlUp(),this.survivors=[];for(let t=1;t<e;t++){const t=l([m,d,D],e-1);this.survivors.push(t.next().value)}this.heroes.members.forEach(e=>this.survivors.push(e.character)),this.heroes=new h(this.survivors,"player",this.gamePlay.boardSize**2),this.enemies=c([g,f,u],1,this.heroes.members.length,this.gamePlay.boardSize**2,"enemy"),this.enemies.randomizedLvlUp(1,e),this.allChars=this.heroes.members.concat(this.enemies.members),this.gamePlay.drawUi(this.theme.getCurrentTheme()),this.refresh()}async onCellClick(e){if(!this.isBlocked){const t=this.heroes.getPositions(),s=this.enemies.getPositions();if(t.includes(e)&&(this.heroes.members.forEach(e=>this.gamePlay.deselectCell(e.position)),this.gamePlay.selectedCharacter=this.heroes.members.find(t=>t.position===e),this.gamePlay.selectCell(e)),null!==this.gamePlay.selectedCharacter){const t=await this.navigation.defineActionArea(this.gamePlay.selectedCharacter,this.gamePlay.boardSize**2,w.move),i=await this.navigation.defineActionArea(this.gamePlay.selectedCharacter,this.gamePlay.boardSize**2,w.attack);if(t.includes(e)&&!s.includes(e)){const t=await this.heroes.findMemberByPosition(this.gamePlay.selectedCharacter.position);t.position=e,console.log(`Игрок: переход ${t.character.type} на клетку ${e}`),this.refresh(),this.deselectAll(),this.gamePlay.selectCell(t.position),this.turn("enemy")}if(i.includes(e)&&s.includes(e)){const t=this.gamePlay.selectedCharacter.character,s=await this.enemies.findMemberByPosition(e);await t.makeDamage(s,this.gamePlay,this),this.turn("enemy")}}}}async onCellEnter(e){if(!this.isBlocked){const t=await this.heroes.getPositions(),s=await this.enemies.getPositions();if(null!==this.gamePlay.selectedCharacter&&this.gamePlay.selectedCharacter.position!==e){const t=await this.navigation.defineActionArea(this.gamePlay.selectedCharacter,this.gamePlay.boardSize**2,w.move);(await this.navigation.defineActionArea(this.gamePlay.selectedCharacter,this.gamePlay.boardSize**2,w.attack)).includes(e)&&s.includes(e)?this.gamePlay.setCursor(p.crosshair):t.includes(e)&&!s.includes(e)?(this.gamePlay.setCursor(p.pointer),this.gamePlay.selectCell(e,"green")):this.gamePlay.setCursor(p.notallowed)}this.getTip(e),t.includes(e)&&this.gamePlay.setCursor(p.pointer)}}onCellLeave(e){this.isBlocked||(this.gamePlay.setCursor(p.auto),null!==this.gamePlay.selectedCharacter&&this.gamePlay.selectedCharacter.position!==e&&this.gamePlay.deselectCell(e))}refresh(){this.gamePlay.redrawPositions(this.allChars)}deselectAll(){for(let e=0;e<this.gamePlay.boardSize**2;e++)null!==this.gamePlay.selectedCharacter&&this.gamePlay.selectedCharacter.position!==e&&this.gamePlay.deselectCell(e)}turn(e){b.turn=e,this.strategyAnalyzer.analyze()}getTip(e){let t=null;if(this.heroes.getPositions().includes(e)?t=this.heroes.findMemberByPosition(e):this.enemies.getPositions().includes(e)&&(t=this.enemies.findMemberByPosition(e)),null!=t){const s=new L(t.character).getHint();this.gamePlay.showCellTooltip(s,e)}}async newGame(){this.theme.setPointer(0),this.deselectAll(),this.isBlocked=!1,this.heroes=await c([m,d],1,2,this.gamePlay.boardSize**2,"player"),this.enemies=await c([g,f,u],1,2,this.gamePlay.boardSize**2,"enemy"),this.allChars=this.heroes.members.concat(this.enemies.members),this.gamePlay.drawUi(this.theme.getCurrentTheme()),this.refresh()}saveGame(){const e=new b(this);this.stateService.save(e),console.log("game progress has been saved!")}async loadGame(){const e=this.stateService.load(),t=[],s=[];for(const s of e.enemyTeam.members)t.push(this.buildCharacterFromRawData(s));for(const t of e.heroesTeam.members)s.push(this.buildCharacterFromRawData(t));this.heroes=new h(s,e.heroesTeam.owner),this.enemies=new h(t,e.enemyTeam.owner),this.allChars=this.heroes.members.concat(this.enemies.members),this.theme.setPointer(e.theme),await this.gamePlay.drawUi(this.theme.getCurrentTheme()),this.refresh(),console.log("the game progress has been loaded!")}buildCharacterFromRawData(e){if(null==e)throw new Error("object is null or undefined");let t;switch(e.character.type){case i.undead:t=new g(1);break;case i.vampire:t=new u(1);break;case i.daemon:t=new f(1);break;case i.swordsman:t=new m(1);break;case i.bowman:t=new d(1);break;case i.magician:t=new D(1);break;default:throw new Error("cant manage this. Unsupported type: "+e.type)}return t.attack=e.character.attack,t.defence=e.character.defence,t.attackDistance=e.character.attackDistance,t.level=e.character.level,t.maxHealth=e.character.maxHealth,t.currentHealth=e.character.currentHealth,new r(t,e.position)}calculateScore(){return this.heroes.countRemainingLives()}}(S,x).init()}]);